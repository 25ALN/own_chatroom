# 聊天室问题总结

## 如何保证udp传输的可靠性
- 模拟tcp的传输  

1. 首先让每一条消息都带上消息头，再加上消息尾，方便进行验证消息的完整；  

2. 当客户端收到消息时，向客户端回复一个ACK表明收到了消息，确保了数据的到达；  

3. 在服务端设置一个时间，当在指定时间未收到客户端的ACK回复时进行超时重传，并且设置一个次数，当传到指定次数时还未收到客户端的ACK时不再进行传输这条消息；  

## 常见锁的种类，以及死锁产生的原因  
- 常见的锁的种类  
1. 互斥锁  
互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即上锁( lock )和解锁(unlock)，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁  
2. 自旋锁  
自旋锁与互斥量功能一样，唯一一点不同的就是互斥量阻塞后休眠让出cpu，而自**旋锁阻塞后不会让出cpu**，会一直忙等待，直到得到锁，原地打转  
自旋锁的使用场景：锁的持有时间比较短，或者说小于2次上下文切换的时间。
3. 读写锁  
互斥量要么是锁住状态，要么就是不加锁状态，而且**一次只有一个线程可以对其加锁**。  
读写锁可以有3种状态：读模式下加锁状态、写模式加锁状态、不加锁状态。  
一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁（允许多个线程读但只允许一个线程写）
- 死锁产生原因  
1. 互斥条件：一个资源每次只能被一个进程使用，如果进程 A 拿着 资源 R1，进程 B 拿着 资源 R2；
A等B手上的资源，B又等A手上的，就会陷入互相等待，形成死锁。；  
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；  
3. 不剥夺条件：进程已获得的资源，在没使用完之前，不能强行剥夺；  
4. 循环等待条件：多个进程之间形成一种互相循环等待资源的关系。并发带来压力，有的人或有的程序，会因为承受不住压力而崩溃，就相当于一个在等另外一个，另一个又在等互相卡住了对方  
  
## fork函数调用后父进程如何将内存复制一份给子进程  
- 首先明确不是直接就进行复制了  
 原因：  
1. 性能开销巨大

一个进程的内存空间可能会非常大，
如果每次 fork() 都要把整个内存一页一页复制一遍，系统就要花费很长时间。

在高并发场景（比如服务器频繁创建子进程），会造成明显的卡顿；

2. 内存浪费

父子进程可能只需要修改很小一部分内存（比如一个变量），但如果直接复制，就会导致整个大块内存被占用两份。
  
解决方案：  
进行**写时复制**，首先是在fork的一瞬间子进程会得到一份和父进程几乎一样的虚拟地址空间，系统会将这些页标记为只读的，当父进程或子进程尝试写这个页时，因为这个页是只读的，会触发页错误，之后内核就会分配一个新的物理页将原来页复制到这里，再让当前进程指向新页再设置为可写的  
总结：***写之前共享，写的时候才分开***  
  
## 页表  
- 概念  
想要把虚拟内存地址，映射到物理内存地址，最直观的方法，就是来键一张映射表。这个映射表，能够实现虚拟内存里面的页，到物理内存里面的页的一一映射。这会映射表，在计算机里面，就叫做页表  
- 多级页表  
  
1. 存在原因   

操作系统使用虚拟内存，把虚拟地址映射到物理内存。

每个进程有自己的虚拟地址空间，例如 32 位系统虚拟地址空=4GB  

内存按页划分，假设每页大小为4KB，如果每个虚拟页都有一个页表项单级页表就需要非常大  
因此就有了多级页表，不为整个虚拟空间一次性分配页表，只为正在使用的部分虚拟页分配。  

2. 为什么大小是4KB  
早期 x86 CPU 采用 32位地址空间（4GB）
如果页太小 → 页表太大，内存浪费在页表上
如果页太大 → 内部碎片严重，每个进程占用的最小内存单位太大
4KB 是 折中值：这样既不会让页表过大
又不会让内部碎片太多

## 在redis持久化中为何RDB恢复数据比AOF更快  
1. RDB是快照式持久化，Redis 会在某个时间点把 内存中的完整数据 写到一个二进制文件（dump.rdb），在恢复时Redis 只需要把这个 RDB 文件一次性读入内存，就能恢复到当时的状态；  
2. AOF 是 追加式持久化，Redis 会把每个写命令以文本形式追加到 appendonly.aof 文件，在恢复时
Redis 需要从头到尾 依次执行文件里的所有命令，才能把内存恢复到最新状态。
如果 AOF 文件很大，命令很多，这个过程会非常慢   
- 总结  

RDB：是内存数据的二进制快照，直接调用read()+memcpy() 就能恢复。  
AOF：是 Redis 命令日志，要逐条解析并执行。  

而且在相同数据量下，RDB 文件通常比 AOF 文件小很多（因为二进制存储比文本命令紧凑），这也使得他的恢复速度会更快 

## tcp的流量控制  
- 这是TCP用来防止发送方发送过快导致接收方缓冲区溢出的一种机制，通过滑动窗口来实现的  

1. 接收窗口

由接收方维护，告诉发送方 自己还能接收多少字节数据

值会在 TCP 报文段头部的 Window 字段 中通知发送方

2. 发送窗口  

由发送方维护，表示 可以发送但未确认的数据量


3. 窗口滑动

当接收方确认了一部分数据后，发送方的窗口向前滑动，可以发送更多数据

- 滑动方式    

1. 收到确认（ACK）后滑动窗口

2. 接收方处理完前 4 KB，并发送 ACK（确认号 = 下一个期望字节）

3. 发送方收到 ACK 后，窗口滑动：已发送且确认的数据从窗口中释放,发送方可以发送更多数据，保持窗口大小不变

## 其余代码问题  
1. 心跳每10秒发送原本用的是sleep，现在已改为timerfd + epoll进行定时发送心跳，由timeerfd来设置定时任务，当在指定时间内未收到客户端的心跳时，由epoll踢出这个套接字；  
2.将多个函数拆分为一个个类，分到不同的文件夹之中